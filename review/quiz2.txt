Ming-hung Shih 932-906-326
Quiz 2 correction

1. with self, balanced binary search tree.

2. (a) amortized O(1)
   (b) O(n)
   (c) amortized O(1)
   (d) O(n)
   (e) amortized O(1)
   (f) O(n)
   (g) O(n)

3. 
   mid = [x for x in a if x == pivot]
   right = [x for x in a if x > pivot]
   return qsort(left) + mid + qsort(right)

4. sort the list
   use two pointer to find pairs x + y = 0
   O(nlogn)
   two pointer from start -> yes, find x = -1/2 * x

5. best-case: O(logn)
   worst-case:O(n)
   def find(t,x,best=None):
	if t==[]:
		return best
	left,root,right = t
	if best is None or abs(root - x) < abs(best - x):
		best = root
	if x < root:
		return find(left,x,best)
	return find(right,x,best)

