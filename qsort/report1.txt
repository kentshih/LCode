CS 519-005, Algorithms (MS/MEng-level), Fall 2016
# Minghung Shih 932906326

HW1 - Python, qsort, and qselect
Due electronically on Canvas on Sunday Sep 25, 11:59pm.
No late submission will be accepted.

Include in your submission: report.txt, qsort.py, and qselect.py.
DO _NOT_ ZIP YOUR SUBMISSION.
qselect.py will be graded for correctness (1%).

Textbooks for References:
[1] CLRS Ch. 9.2 and Ch. 12

0. Q: What's the best-case, worst-case, and average-case time complexities of quicksort.
   Briefly explain each case.

	best-case: O(nlogn), when every partition is evenly balanced, it took cn + 2*cn/2 +…+ n*cn/n = O(nlogn)
	worst-case: O(n^2), when the most unbalanced partition occur constantly, it took cn + c(n-1) + … + c (n-n) = O(n^2) to sort the list.
	average-case: O(nlogn), when the partition is not most unbalanced, it took cn + c*(n/3+2n/3)+…+c*n = O(logn)

1. [WILL BE GRADED] 
   Quickselect with Randomized Pivot (CLRS Ch. 9.2).

   >>> from qselect import *
   >>> qselect(2, [3, 10, 4, 7, 19])
   4
   >>> qselect(4, [11, 2, 8, 3])
   11

   Q: What's the best-case, worst-case, and average-case time complexities? Briefly explain.

   Filename: qselect.py

	best-case: O(1), first choose pivot and match, only take O(1)
	worst-case: O(n), every time choose the uneven side, take n times to find the target, cost O(n) 
	average-case: O(logn), every time choose average balanced partition, it took 1+1/2+…+1/n = O(logn) to find the target.


2. Buggy Qsort Revisited

   In the slides we showed a buggy version of qsort which is weird in an interesting way:
   it actually returns a binary search tree for the given array, rooted at the pivot:

   >>> from qsort import *
   >>> tree = sort([4,2,6,3,5,7,1,9])
   >>> tree
   [[[[], 1, []], 2, [[], 3, []]], 4, [[[], 5, []], 6, [[], 7, [[], 9, []]]]]

   which encodes a binary search tree:

                      4
                    /   \
                  2       6
                 / \     / \
                1   3   5   7
                             \
                              9
   
   Now on top of that piece of code, add three functions: 
   * sorted(t): returns the sorted order (infix traversal)
   * search(t, x): returns whether x is in t
   * insert(t, x): inserts x into t (in-place) if it is missing, otherwise does nothing.

   >>> sorted(tree)
   [1, 2, 3, 4, 5, 6, 7, 9]
   >>> search(tree, 6)
   True
   >>> search(tree, 6.5)
   False
   >>> insert(tree, 6.5)
   >>> tree
   [[[[], 1, []], 2, [[], 3, []]], 4, [[[], 5, []], 6, [[[], 6.5, []], 7, [[], 9, []]]]]
   >>> insert(tree, 3)
   >>> tree
   [[[[], 1, []], 2, [[], 3, []]], 4, [[[], 5, []], 6, [[[], 6.5, []], 7, [[], 9, []]]]]

   Hint: both search and insert should depend on a helper function _search(tree, x) which 
   returns the subtree (a list) rooted at x when x is found, or the [] where x should 
   be inserted.

   e.g., 
   >>> tree = sort([4,2,6,3,5,7,1,9])        # starting from the initial tree
   >>> _search(tree, 3)
   [[], 3, []]
   >>> _search(tree, 0)
   []
   >>> _search(tree, 6.5)
   []
   >>> _search(tree, 0) is _search(tree, 6.5)
   False
   >>> _search(tree, 0) == _search(tree, 6.5)
   True
   
   Note the last two []'s are different nodes (with different memory addresses): 
   the first one is the left child of 1, while the second one is the left child of 7
   (so that insert is very easy).
   
   Filename: qsort.py
   
   Q: What are the time complexities for the operations implemented?

Debriefing (required!): --------------------------

1. Approximately how many hours did you spend on this assignment?
20 hours
2. Would you rate it as easy, moderate, or difficult?
difficult
3. Did you work on it mostly alone, or mostly with other people?
alone
4. How deeply do you feel you understand the material it covers (0%–100%)? 
70%
5. Any other comments?
No

