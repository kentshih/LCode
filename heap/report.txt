CS 519-005, Algorithms (MS/MEng-level), Fall 2016
HW4 - Heaps
Ming-hung Shih 932-905-326 ONID:shihm

Due electronically on Canvas on Sunday Oct 16, 11:59pm.
No late submission will be accepted.

Include in your submission: report.txt, nbest.py, kmergesort.py, datastream.py.
DO _NOT_ ZIP YOUR SUBMISSION.
datastream.py will be graded for correctness (1%).

Textbooks for References:
[1] CLRS Ch. 6
[2] Python heapq module -- https://docs.python.org/2/library/heapq.html

0. There are two methods for building a heap from an unsorted array:
   (1) insert each element into the heap  --- O(nlogn)
   (2) heapify (top-down)                 --- O(n)

   (a) (theoretically) Derive their time complexities.
   (b) (empirically)   Use a long list of random numbers to show the difference in time.
       		       What about sorted or reversely-sorted numbers?

   Write your answers to (a) and (b) in report.txt.
   (a) (1) T(n) = 1/2 * T(n - 1) = O(nlogn)
       (2) T(n) = n * 1/2 = O(n)
   (b) random numbers is average case, (1) = O(nlogn) < (2) = O(n)
       sorted numbers = best case, (1) = (2) approximately
       reversely-sorted numbers = worse case, (1) = (2) approximately

1. (taken from my first paper: see "Algorithm 1" in Huang and Chiang (2005).)

   Given two lists A and B, each with n integers, return
   a sorted list C that contains the smallest n elements from AxB:

     AxB = { (x, y) | x in A, y in B }

   i.e., AxB is the Cartesian Product of A and B.

   ordering:  (x,y) < (x',y') iff. x+y < x'+y' or (x+y==x'+y' and y<y')

   You need to implement three algorithms and compare:

   (a) enumerate all n^2 pairs, sort, and take top n.
   (b) enumerate all n^2 pairs, but use qselect from hw1.
   (c) Dijkstra-style best-first, only enumerate O(n) (at most 2n) pairs.
       Hint: you can use Python's heapq module for priority queue.

   Q: What are the time complexities of these algorithms? 
   A: (a) O(n^2)
      (b) O(nlogn)
      (c) O(n)

   >>> a, b = [4, 1, 5, 3], [2, 6, 3, 4]
   >>> nbesta(a, b)   # algorithm (a), slowest
   [(1, 2), (1, 3), (3, 2), (1, 4)]
   >>> nbestb(a, b)   # algorithm (b), slow
   [(1, 2), (1, 3), (3, 2), (1, 4)]
   >>> nbestc(a, b)   # algorithm (c), fast
   [(1, 2), (1, 3), (3, 2), (1, 4)]

   Filename: nbest.py

2. k-way mergesort (the classical mergesort is a special case where k=2).

   >>> kmergesort([4,1,5,2,6,3,7,0], 3) 
   [0,1,2,3,4,5,6,7]

   Q: What is the complexity? Write down the detailed analysis in report.txt.
   A: to k-way: O(nlogn)
      devide and merge: O(klogk)
      total: O(nlogn+klogk)

   Filename: kmergesort.py

3. [WILL BE GRADED]
   
   Find the k smallest numbers in a data stream of length n (k<<n),
   using only O(k) space (the stream itself might be too big to fit in memory).

   >>> ksmallest(4, [10, 2, 9, 3, 7, 8, 11, 5, 7])
   [2, 3, 5, 7]
   >>> ksmallest(3, xrange(1000000, 0, -1))
   [1, 2, 3]

   Note: 
   a) it should work with both lists and lazy lists
   b) the output list should be sorted

   Q: What is your complexity? Write down the detailed analysis in report.txt.

   A: Time complexity: O(n) to visit every element, O(k) to pop heap, O(k) to sort list, O(n+k) totally
      space: O(k) to store heap
   
   Filename: datastream.py

Debriefing (required!): --------------------------

1. Approximately how many hours did you spend on this assignment?
20hr
2. Would you rate it as easy, moderate, or difficult?
difficult
3. Did you work on it mostly alone, or mostly with other people?
   Note you are encouraged to discuss with your classmates, 
   but each students should submit his/her own code.
mostly alone
4. How deeply do you feel you understand the material it covers (0%â€“100%)? 
60%
5. Which part(s) of the course you like the most so far?
homework
6. Which part(s) of the course you dislike the most so far?
quiz

This section is intended to help us calibrate the homework assignments. 
Your answers to this section will *not* affect your grade; however, skipping it
will certainly do.
